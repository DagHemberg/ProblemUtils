package problemutils.classes.graphs

import scala.collection.mutable
import scala.annotation.targetName
import problemutils.extensions.*
import problemutils.classes.Matrix

// TODO
// - components: Set[Graph[V]]
// - stronglyConnectedComponents: Set[Graph[V]]

trait Graph[V]:
  import Graph.*
  protected given adjacentTo: (V => Set[Edge[V]])

  def edges: Set[Edge[V]]
  def edgesFrom: Map[V, Set[Edge[V]]]
  def edgesTo: Map[V, Set[Edge[V]]]
  def vertices: Set[V]

  def filterEdges(p: Edge[V] => Boolean): Graph[V]
  def filterVertices(p: V => Boolean): Graph[V]

  def incl(e: Edge[V]): Graph[V]
  def excl(e: Edge[V]): Graph[V]

  def union(g: Graph[V]): Graph[V]
  def intersect(g: Graph[V]): Graph[V]
  def diff(g: Graph[V]): Graph[V]

  def +(e: Edge[V]) = incl(e)
  def -(e: Edge[V]) = excl(e)
  
  def &(g: Graph[V]) = intersect(g)
  def |(g: Graph[V]) = union(g)
  def \(g: Graph[V]) = diff(g)
  
  def apply(v: V) = adjacentTo(v).map(_.to)
  def apply(a: V, b: V) = adjacentTo(a).find(_.to == b).map(_.weight)

  def allPathsFrom(start: V) = 
    Pathfinder.dijkstra(start)
  
  def shortestPath(start: V, end: V, heuristic: V => Double = _ => 0) = 
    Pathfinder.aStar(start, _ == end, heuristic)
  
  def shortestPathUntil(start: V, endPred: V => Boolean, heuristic: V => Double = _ => 0) = 
    Pathfinder.aStar(start, endPred, heuristic)

  def reachableFrom(start: V) = 
    allPathsFrom(start).map(_.last)

object Graph:
  import Pathfinder.*

  def apply[V](elems: (V, V)*) = FiniteGraph.from(elems.map(Edge(_, _)).toSet)

  def from[V](edges: IterableOnce[Edge[V]]) = FiniteGraph.from(edges.iterator.toSet)

  def fromTuples[V](edges: IterableOnce[(V, V)]) = FiniteGraph.from(edges.iterator.map(Edge(_, _)).toSet)
  
  /** Creates a lazily generated graph where the edges between vertices are procedurally generated by the given adjacency function. */
  def generate[V](adjacencyFunction: V => IterableOnce[V]) = 
    ProceduralGraph(adjacencyFunction)
  
  def generateWith[V](adjacencyFunction: V => IterableOnce[Edge[V]]) = 
    ProceduralGraph.from(adjacencyFunction andThen (_.iterator.toSet))

  /** Creates a lazily generated graph where the edges between vertices are procedurally generated by the given adjacency function and then cached. */
  def generateLazily[V](adjacencyFunction: V => IterableOnce[V]) = 
    LazyGraph(adjacencyFunction)
  
  def generateLazilyWith[V](adjacencyFunction: V => IterableOnce[Edge[V]]) = 
    LazyGraph.from(adjacencyFunction andThen (_.iterator.toSet))
    
  def empty[V]: Graph[V] = FiniteGraph.empty[V]

  def fromMap[V](map: Map[V, IterableOnce[V]]) = 
    map.foldLeft(Graph.empty[V]):
      case (graph, (from, connections)) => 
        graph union connections.iterator.toSet.map(from ->> _).foldLeft(Graph.empty)(_ + _)
  
  def fromMatrix[V](matrix: Matrix[V], joined: (V, V) => Boolean, cost: (V, V) => Double = (a: V, b: V) => 1.0): Graph[V] = 
    
    val vec = matrix.toVector
    val edges = 
      for 
        v1 <- vec
        v2 <- vec 
        if joined(v1, v2)
      yield 
        Edge(v1, v2, cost(v1, v2))
    
    Graph.from(edges)
