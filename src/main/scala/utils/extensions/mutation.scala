package utils.extensions
import utils.*

extension [A](a: A)
  /** Applies any function `A => A` on any object `n` times. If `n` is less than or equal to 0, the original object is returned without function application. */
  def iterate(f: A => A)(n: Int): A = 
    if n <= 0 then a
    else f(a).iterate(f)(n - 1)

  /** Recursively applies a function `f: A => A` on any object `a` until the predicate `p` is satisfied. */
  def doUntil(p: A => Boolean)(f: A => A): A = 
    if p(a) then a
    else f(a).doUntil(p)(f)

  /** Recursively applies a function `f: A => A` on any object `a` until `f(a)` is equal to `a`. */
  def converge(f: A => A): A = 
    val fa = f(a)
    if a == fa then a
    else fa.converge(f)

  /** Performs a flood-fill using a neighbour function `f: A => IterableOnce[A]`. Returns a set of all elements generated by the function with the starting point `a`. */
  def expand(f: A => IterableOnce[A]): Set[A] = 
    val set = Set(a)
    def helper(collected: Set[A], prev: Set[A]) = 
      (collected.diff(prev).flatMap(f).union(collected), collected)

    (set flatMap f, set).converge(helper).head
